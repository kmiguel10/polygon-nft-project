{
  "language": "Solidity",
  "sources": {
    "src/contracts/mocks/DynamicSvgtNft.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"base64-sol/base64.sol\";\nimport \"../tokens/nf-token-metadata.sol\";\nimport \"../ownership/ownable.sol\";\n\ncontract DynamicSvgNft is NFTokenMetadata, Ownable {\n    //mint an NFT based on price of ETH\n    //if ETH someNumber: Smile\n    //otherwise: Frown\n\n    uint public s_tokenCounter;\n    string public s_lowImageURI;\n    string public s_highImageURI;\n    int256 public immutable i_highValue;\n    AggregatorV3Interface public immutable i_priceFeed;\n\n    //Pass SVG files and convert those files to base64 format\n    constructor(\n        address priceFeedAddress,\n        string memory lowSvg,\n        string memory highSvg,\n        int256 highValue\n    ) ERC721() {\n        s_tokenCounter = 0;\n        s_lowImageURI = svgToImageURI(lowSvg);\n        s_highImageURI = svgToImageURI(highSvg);\n        i_priceFeed = AggregatorV3Interface(priceFeedAddress);\n        i_highValue = highValue;\n    }\n\n    //returns imageURIs\n    function svgToImageURI(string memory svg)\n        public\n        pure\n        returns (string memory)\n    {\n        string memory baseImageURL = \"data:image/svg+xml;base64,\";\n        string memory svgBase64Encoded = Base64.encode(\n            bytes(string(abi.encodePacked(svg)))\n        );\n\n        return string(abi.encodePacked(baseImageURL, svgBase64Encoded));\n    }\n\n    // function mintNft() external {\n    //     _safeMint(msg.sender, s_tokenCounter);\n    //     s_tokenCounter = s_tokenCounter + 1;\n    // }\n\n    /**\n     * @dev Mints a new NFT.\n     * @param _to The address that will own the minted NFT.\n     * @param _tokenId of the NFT to be minted by the msg.sender.\n     */\n    function mint(address _to, uint256 _tokenId) external onlyOwner {\n        super._mint(_to, _tokenId);\n        s_tokenCounter = s_tokenCounter + 1;\n    }\n\n    //Returns string to be used from converting svg -> base64\n    function _baseURI() internal pure returns (string memory) {\n        return \"data:application/json\";\n    }\n\n    //override tokenURI inherited function from ERC721\n    //\"virtual\" means function can be overriden\n    function tokenURI(\n        uint /*tokenId*/\n    ) public view override returns (string memory) {\n        //How do we base64 encode this string -> URL/URI\n        //How do we get the image?\n        (, int256 price, , , ) = i_priceFeed.latestRoundData();\n        string memory imageUri = s_lowImageURI;\n        if (price > i_highValue) {\n            imageUri = s_highImageURI;\n        }\n\n        bytes memory metaDataTemplate = (\n            abi.encodePacked(\n                '{\"name\":\"Dynamic SVG\", \"description\": \"a cool NFT\", \"attributes\":[{\"trait_type\":\"coolness\",\"value\":100}], \"image\":\",imageUri,\"\"\"}'\n            )\n        );\n\n        bytes memory metaDataTemplateinBytes = bytes(metaDataTemplate);\n        string memory encodedMetadata = Base64.encode(metaDataTemplateinBytes);\n        return (string(abi.encodePacked(_baseURI(), encodedMetadata))); //concatenate string\n    }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "base64-sol/base64.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\n/// @title Base64\n/// @author Brecht Devos - <brecht@loopring.org>\n/// @notice Provides functions for encoding/decoding base64\nlibrary Base64 {\n    string internal constant TABLE_ENCODE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n    bytes  internal constant TABLE_DECODE = hex\"0000000000000000000000000000000000000000000000000000000000000000\"\n                                            hex\"00000000000000000000003e0000003f3435363738393a3b3c3d000000000000\"\n                                            hex\"00000102030405060708090a0b0c0d0e0f101112131415161718190000000000\"\n                                            hex\"001a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132330000000000\";\n\n    function encode(bytes memory data) internal pure returns (string memory) {\n        if (data.length == 0) return '';\n\n        // load the table into memory\n        string memory table = TABLE_ENCODE;\n\n        // multiply by 4/3 rounded up\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\n\n        // add some extra buffer at the end required for the writing\n        string memory result = new string(encodedLen + 32);\n\n        assembly {\n            // set the actual output length\n            mstore(result, encodedLen)\n\n            // prepare the lookup table\n            let tablePtr := add(table, 1)\n\n            // input ptr\n            let dataPtr := data\n            let endPtr := add(dataPtr, mload(data))\n\n            // result ptr, jump over length\n            let resultPtr := add(result, 32)\n\n            // run over the input, 3 bytes at a time\n            for {} lt(dataPtr, endPtr) {}\n            {\n                // read 3 bytes\n                dataPtr := add(dataPtr, 3)\n                let input := mload(dataPtr)\n\n                // write 4 characters\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(shr( 6, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(        input,  0x3F))))\n                resultPtr := add(resultPtr, 1)\n            }\n\n            // padding with '='\n            switch mod(mload(data), 3)\n            case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }\n            case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }\n        }\n\n        return result;\n    }\n\n    function decode(string memory _data) internal pure returns (bytes memory) {\n        bytes memory data = bytes(_data);\n\n        if (data.length == 0) return new bytes(0);\n        require(data.length % 4 == 0, \"invalid base64 decoder input\");\n\n        // load the table into memory\n        bytes memory table = TABLE_DECODE;\n\n        // every 4 characters represent 3 bytes\n        uint256 decodedLen = (data.length / 4) * 3;\n\n        // add some extra buffer at the end required for the writing\n        bytes memory result = new bytes(decodedLen + 32);\n\n        assembly {\n            // padding with '='\n            let lastBytes := mload(add(data, mload(data)))\n            if eq(and(lastBytes, 0xFF), 0x3d) {\n                decodedLen := sub(decodedLen, 1)\n                if eq(and(lastBytes, 0xFFFF), 0x3d3d) {\n                    decodedLen := sub(decodedLen, 1)\n                }\n            }\n\n            // set the actual output length\n            mstore(result, decodedLen)\n\n            // prepare the lookup table\n            let tablePtr := add(table, 1)\n\n            // input ptr\n            let dataPtr := data\n            let endPtr := add(dataPtr, mload(data))\n\n            // result ptr, jump over length\n            let resultPtr := add(result, 32)\n\n            // run over the input, 4 characters at a time\n            for {} lt(dataPtr, endPtr) {}\n            {\n               // read 4 characters\n               dataPtr := add(dataPtr, 4)\n               let input := mload(dataPtr)\n\n               // write 3 bytes\n               let output := add(\n                   add(\n                       shl(18, and(mload(add(tablePtr, and(shr(24, input), 0xFF))), 0xFF)),\n                       shl(12, and(mload(add(tablePtr, and(shr(16, input), 0xFF))), 0xFF))),\n                   add(\n                       shl( 6, and(mload(add(tablePtr, and(shr( 8, input), 0xFF))), 0xFF)),\n                               and(mload(add(tablePtr, and(        input , 0xFF))), 0xFF)\n                    )\n                )\n                mstore(resultPtr, shl(232, output))\n                resultPtr := add(resultPtr, 3)\n            }\n        }\n\n        return result;\n    }\n}\n"
    },
    "src/contracts/tokens/nf-token-metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport \"./nf-token.sol\";\nimport \"./erc721-metadata.sol\";\n\n/**\n * @dev Optional metadata implementation for ERC-721 non-fungible token standard.\n */\ncontract NFTokenMetadata is NFToken, ERC721Metadata {\n    /**\n     * @dev A descriptive name for a collection of NFTs.\n     */\n    string internal nftName;\n\n    /**\n     * @dev An abbreviated name for NFTokens.\n     */\n    string internal nftSymbol;\n\n    /**\n     * @dev Mapping from NFT ID to metadata uri.\n     */\n    mapping(uint256 => string) internal idToUri;\n\n    /**\n     * @notice When implementing this contract don't forget to set nftName and nftSymbol.\n     * @dev Contract constructor.\n     */\n    constructor() {\n        supportedInterfaces[0x5b5e139f] = true; // ERC721Metadata\n    }\n\n    /**\n     * @dev Returns a descriptive name for a collection of NFTokens.\n     * @return _name Representing name.\n     */\n    function name() external view override returns (string memory _name) {\n        _name = nftName;\n    }\n\n    /**\n     * @dev Returns an abbreviated name for NFTokens.\n     * @return _symbol Representing symbol.\n     */\n    function symbol() external view override returns (string memory _symbol) {\n        _symbol = nftSymbol;\n    }\n\n    /**\n     * @dev A distinct URI (RFC 3986) for a given NFT.\n     * @param _tokenId Id for which we want uri.\n     * @return URI of _tokenId.\n     */\n    function tokenURI(uint256 _tokenId)\n        external\n        view\n        virtual\n        override\n        validNFToken(_tokenId)\n        returns (string memory)\n    {\n        return _tokenURI(_tokenId);\n    }\n\n    /**\n     * @notice This is an internal function that can be overriden if you want to implement a different\n     * way to generate token URI.\n     * @param _tokenId Id for which we want uri.\n     * @return URI of _tokenId.\n     */\n    function _tokenURI(uint256 _tokenId)\n        internal\n        view\n        virtual\n        returns (string memory)\n    {\n        return idToUri[_tokenId];\n    }\n\n    /**\n     * @notice This is an internal function which should be called from user-implemented external\n     * burn function. Its purpose is to show and properly initialize data structures when using this\n     * implementation. Also, note that this burn implementation allows the minter to re-mint a burned\n     * NFT.\n     * @dev Burns a NFT.\n     * @param _tokenId ID of the NFT to be burned.\n     */\n    function _burn(uint256 _tokenId) internal virtual override {\n        super._burn(_tokenId);\n\n        delete idToUri[_tokenId];\n    }\n\n    /**\n     * @notice This is an internal function which should be called from user-implemented external\n     * function. Its purpose is to show and properly initialize data structures when using this\n     * implementation.\n     * @dev Set a distinct URI (RFC 3986) for a given NFT ID.\n     * @param _tokenId Id for which we want URI.\n     * @param _uri String representing RFC 3986 URI.\n     */\n    function _setTokenUri(uint256 _tokenId, string memory _uri)\n        internal\n        validNFToken(_tokenId)\n    {\n        idToUri[_tokenId] = _uri;\n    }\n}\n"
    },
    "src/contracts/ownership/ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\n/**\n * @dev The contract has an owner address, and provides basic authorization control whitch\n * simplifies the implementation of user permissions. This contract is based on the source code at:\n * https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/ownership/Ownable.sol\n */\ncontract Ownable {\n    /**\n     * @dev Error constants.\n     */\n    string public constant NOT_CURRENT_OWNER = \"018001\";\n    string public constant CANNOT_TRANSFER_TO_ZERO_ADDRESS = \"018002\";\n\n    /**\n     * @dev Current owner address.\n     */\n    address public owner;\n\n    /**\n     * @dev An event which is triggered when the owner is changed.\n     * @param previousOwner The address of the previous owner.\n     * @param newOwner The address of the new owner.\n     */\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /**\n     * @dev The constructor sets the original `owner` of the contract to the sender account.\n     */\n    constructor() {\n        owner = msg.sender;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(msg.sender == owner, NOT_CURRENT_OWNER);\n        _;\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param _newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address _newOwner) public onlyOwner {\n        require(_newOwner != address(0), CANNOT_TRANSFER_TO_ZERO_ADDRESS);\n        emit OwnershipTransferred(owner, _newOwner);\n        owner = _newOwner;\n    }\n}\n"
    },
    "src/contracts/tokens/nf-token.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport \"./erc721.sol\";\nimport \"./erc721-token-receiver.sol\";\nimport \"../utils/supports-interface.sol\";\nimport \"../utils/address-utils.sol\";\n\n/**\n * @dev Implementation of ERC-721 non-fungible token standard.\n */\ncontract NFToken is ERC721, SupportsInterface {\n    using AddressUtils for address;\n\n    /**\n     * @dev List of revert message codes. Implementing dApp should handle showing the correct message.\n     * Based on 0xcert framework error codes.\n     */\n    string constant ZERO_ADDRESS = \"003001\";\n    string constant NOT_VALID_NFT = \"003002\";\n    string constant NOT_OWNER_OR_OPERATOR = \"003003\";\n    string constant NOT_OWNER_APPROVED_OR_OPERATOR = \"003004\";\n    string constant NOT_ABLE_TO_RECEIVE_NFT = \"003005\";\n    string constant NFT_ALREADY_EXISTS = \"003006\";\n    string constant NOT_OWNER = \"003007\";\n    string constant IS_OWNER = \"003008\";\n\n    /**\n     * @dev Magic value of a smart contract that can receive NFT.\n     * Equal to: bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\")).\n     */\n    bytes4 internal constant MAGIC_ON_ERC721_RECEIVED = 0x150b7a02;\n\n    /**\n     * @dev A mapping from NFT ID to the address that owns it.\n     */\n    mapping(uint256 => address) internal idToOwner;\n\n    /**\n     * @dev Mapping from NFT ID to approved address.\n     */\n    mapping(uint256 => address) internal idToApproval;\n\n    /**\n     * @dev Mapping from owner address to count of their tokens.\n     */\n    mapping(address => uint256) private ownerToNFTokenCount;\n\n    /**\n     * @dev Mapping from owner address to mapping of operator addresses.\n     */\n    mapping(address => mapping(address => bool)) internal ownerToOperators;\n\n    /**\n     * @dev Guarantees that the msg.sender is an owner or operator of the given NFT.\n     * @param _tokenId ID of the NFT to validate.\n     */\n    modifier canOperate(uint256 _tokenId) {\n        address tokenOwner = idToOwner[_tokenId];\n        require(\n            tokenOwner == msg.sender ||\n                ownerToOperators[tokenOwner][msg.sender],\n            NOT_OWNER_OR_OPERATOR\n        );\n        _;\n    }\n\n    /**\n     * @dev Guarantees that the msg.sender is allowed to transfer NFT.\n     * @param _tokenId ID of the NFT to transfer.\n     */\n    modifier canTransfer(uint256 _tokenId) {\n        address tokenOwner = idToOwner[_tokenId];\n        require(\n            tokenOwner == msg.sender ||\n                idToApproval[_tokenId] == msg.sender ||\n                ownerToOperators[tokenOwner][msg.sender],\n            NOT_OWNER_APPROVED_OR_OPERATOR\n        );\n        _;\n    }\n\n    /**\n     * @dev Guarantees that _tokenId is a valid Token.\n     * @param _tokenId ID of the NFT to validate.\n     */\n    modifier validNFToken(uint256 _tokenId) {\n        require(idToOwner[_tokenId] != address(0), NOT_VALID_NFT);\n        _;\n    }\n\n    /**\n     * @dev Contract constructor.\n     */\n    constructor() {\n        supportedInterfaces[0x80ac58cd] = true; // ERC721\n    }\n\n    /**\n     * @notice Throws unless `msg.sender` is the current owner, an authorized operator, or the\n     * approved address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is\n     * the zero address. Throws if `_tokenId` is not a valid NFT. When transfer is complete, this\n     * function checks if `_to` is a smart contract (code size > 0). If so, it calls\n     * `onERC721Received` on `_to` and throws if the return value is not\n     * `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`.\n     * @dev Transfers the ownership of an NFT from one address to another address. This function can\n     * be changed to payable.\n     * @param _from The current owner of the NFT.\n     * @param _to The new owner.\n     * @param _tokenId The NFT to transfer.\n     * @param _data Additional data with no specified format, sent in call to `_to`.\n     */\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId,\n        bytes calldata _data\n    ) external override {\n        _safeTransferFrom(_from, _to, _tokenId, _data);\n    }\n\n    /**\n     * @notice This works identically to the other function with an extra data parameter, except this\n     * function just sets data to \"\".\n     * @dev Transfers the ownership of an NFT from one address to another address. This function can\n     * be changed to payable.\n     * @param _from The current owner of the NFT.\n     * @param _to The new owner.\n     * @param _tokenId The NFT to transfer.\n     */\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) external override {\n        _safeTransferFrom(_from, _to, _tokenId, \"\");\n    }\n\n    /**\n     * @notice The caller is responsible to confirm that `_to` is capable of receiving NFTs or else\n     * they may be permanently lost.\n     * @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\n     * address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is the zero\n     * address. Throws if `_tokenId` is not a valid NFT. This function can be changed to payable.\n     * @param _from The current owner of the NFT.\n     * @param _to The new owner.\n     * @param _tokenId The NFT to transfer.\n     */\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) external override canTransfer(_tokenId) validNFToken(_tokenId) {\n        address tokenOwner = idToOwner[_tokenId];\n        require(tokenOwner == _from, NOT_OWNER);\n        require(_to != address(0), ZERO_ADDRESS);\n\n        _transfer(_to, _tokenId);\n    }\n\n    /**\n     * @notice The zero address indicates there is no approved address. Throws unless `msg.sender` is\n     * the current NFT owner, or an authorized operator of the current owner.\n     * @dev Set or reaffirm the approved address for an NFT. This function can be changed to payable.\n     * @param _approved Address to be approved for the given NFT ID.\n     * @param _tokenId ID of the token to be approved.\n     */\n    function approve(address _approved, uint256 _tokenId)\n        external\n        override\n        canOperate(_tokenId)\n        validNFToken(_tokenId)\n    {\n        address tokenOwner = idToOwner[_tokenId];\n        require(_approved != tokenOwner, IS_OWNER);\n\n        idToApproval[_tokenId] = _approved;\n        emit Approval(tokenOwner, _approved, _tokenId);\n    }\n\n    /**\n     * @notice This works even if sender doesn't own any tokens at the time.\n     * @dev Enables or disables approval for a third party (\"operator\") to manage all of\n     * `msg.sender`'s assets. It also emits the ApprovalForAll event.\n     * @param _operator Address to add to the set of authorized operators.\n     * @param _approved True if the operators is approved, false to revoke approval.\n     */\n    function setApprovalForAll(address _operator, bool _approved)\n        external\n        override\n    {\n        ownerToOperators[msg.sender][_operator] = _approved;\n        emit ApprovalForAll(msg.sender, _operator, _approved);\n    }\n\n    /**\n     * @dev Returns the number of NFTs owned by `_owner`. NFTs assigned to the zero address are\n     * considered invalid, and this function throws for queries about the zero address.\n     * @param _owner Address for whom to query the balance.\n     * @return Balance of _owner.\n     */\n    function balanceOf(address _owner)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        require(_owner != address(0), ZERO_ADDRESS);\n        return _getOwnerNFTCount(_owner);\n    }\n\n    /**\n     * @dev Returns the address of the owner of the NFT. NFTs assigned to the zero address are\n     * considered invalid, and queries about them do throw.\n     * @param _tokenId The identifier for an NFT.\n     * @return _owner Address of _tokenId owner.\n     */\n    function ownerOf(uint256 _tokenId)\n        external\n        view\n        override\n        returns (address _owner)\n    {\n        _owner = idToOwner[_tokenId];\n        require(_owner != address(0), NOT_VALID_NFT);\n    }\n\n    /**\n     * @notice Throws if `_tokenId` is not a valid NFT.\n     * @dev Get the approved address for a single NFT.\n     * @param _tokenId ID of the NFT to query the approval of.\n     * @return Address that _tokenId is approved for.\n     */\n    function getApproved(uint256 _tokenId)\n        external\n        view\n        override\n        validNFToken(_tokenId)\n        returns (address)\n    {\n        return idToApproval[_tokenId];\n    }\n\n    /**\n     * @dev Checks if `_operator` is an approved operator for `_owner`.\n     * @param _owner The address that owns the NFTs.\n     * @param _operator The address that acts on behalf of the owner.\n     * @return True if approved for all, false otherwise.\n     */\n    function isApprovedForAll(address _owner, address _operator)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return ownerToOperators[_owner][_operator];\n    }\n\n    /**\n     * @notice Does NO checks.\n     * @dev Actually performs the transfer.\n     * @param _to Address of a new owner.\n     * @param _tokenId The NFT that is being transferred.\n     */\n    function _transfer(address _to, uint256 _tokenId) internal virtual {\n        address from = idToOwner[_tokenId];\n        _clearApproval(_tokenId);\n\n        _removeNFToken(from, _tokenId);\n        _addNFToken(_to, _tokenId);\n\n        emit Transfer(from, _to, _tokenId);\n    }\n\n    /**\n     * @notice This is an internal function which should be called from user-implemented external\n     * mint function. Its purpose is to show and properly initialize data structures when using this\n     * implementation.\n     * @dev Mints a new NFT.\n     * @param _to The address that will own the minted NFT.\n     * @param _tokenId of the NFT to be minted by the msg.sender.\n     */\n    function _mint(address _to, uint256 _tokenId) internal virtual {\n        require(_to != address(0), ZERO_ADDRESS);\n        require(idToOwner[_tokenId] == address(0), NFT_ALREADY_EXISTS);\n\n        _addNFToken(_to, _tokenId);\n\n        emit Transfer(address(0), _to, _tokenId);\n    }\n\n    /**\n     * @notice This is an internal function which should be called from user-implemented external burn\n     * function. Its purpose is to show and properly initialize data structures when using this\n     * implementation. Also, note that this burn implementation allows the minter to re-mint a burned\n     * NFT.\n     * @dev Burns a NFT.\n     * @param _tokenId ID of the NFT to be burned.\n     */\n    function _burn(uint256 _tokenId) internal virtual validNFToken(_tokenId) {\n        address tokenOwner = idToOwner[_tokenId];\n        _clearApproval(_tokenId);\n        _removeNFToken(tokenOwner, _tokenId);\n        emit Transfer(tokenOwner, address(0), _tokenId);\n    }\n\n    /**\n     * @notice Use and override this function with caution. Wrong usage can have serious consequences.\n     * @dev Removes a NFT from owner.\n     * @param _from Address from which we want to remove the NFT.\n     * @param _tokenId Which NFT we want to remove.\n     */\n    function _removeNFToken(address _from, uint256 _tokenId) internal virtual {\n        require(idToOwner[_tokenId] == _from, NOT_OWNER);\n        ownerToNFTokenCount[_from] -= 1;\n        delete idToOwner[_tokenId];\n    }\n\n    /**\n     * @notice Use and override this function with caution. Wrong usage can have serious consequences.\n     * @dev Assigns a new NFT to owner.\n     * @param _to Address to which we want to add the NFT.\n     * @param _tokenId Which NFT we want to add.\n     */\n    function _addNFToken(address _to, uint256 _tokenId) internal virtual {\n        require(idToOwner[_tokenId] == address(0), NFT_ALREADY_EXISTS);\n\n        idToOwner[_tokenId] = _to;\n        ownerToNFTokenCount[_to] += 1;\n    }\n\n    /**\n     * @dev Helper function that gets NFT count of owner. This is needed for overriding in enumerable\n     * extension to remove double storage (gas optimization) of owner NFT count.\n     * @param _owner Address for whom to query the count.\n     * @return Number of _owner NFTs.\n     */\n    function _getOwnerNFTCount(address _owner)\n        internal\n        view\n        virtual\n        returns (uint256)\n    {\n        return ownerToNFTokenCount[_owner];\n    }\n\n    /**\n     * @dev Actually perform the safeTransferFrom.\n     * @param _from The current owner of the NFT.\n     * @param _to The new owner.\n     * @param _tokenId The NFT to transfer.\n     * @param _data Additional data with no specified format, sent in call to `_to`.\n     */\n    function _safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId,\n        bytes memory _data\n    ) private canTransfer(_tokenId) validNFToken(_tokenId) {\n        address tokenOwner = idToOwner[_tokenId];\n        require(tokenOwner == _from, NOT_OWNER);\n        require(_to != address(0), ZERO_ADDRESS);\n\n        _transfer(_to, _tokenId);\n\n        if (_to.isContract()) {\n            bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(\n                msg.sender,\n                _from,\n                _tokenId,\n                _data\n            );\n            require(\n                retval == MAGIC_ON_ERC721_RECEIVED,\n                NOT_ABLE_TO_RECEIVE_NFT\n            );\n        }\n    }\n\n    /**\n     * @dev Clears the current approval of a given NFT ID.\n     * @param _tokenId ID of the NFT to be transferred.\n     */\n    function _clearApproval(uint256 _tokenId) private {\n        delete idToApproval[_tokenId];\n    }\n}\n"
    },
    "src/contracts/tokens/erc721-metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\n/**\n * @dev Optional metadata extension for ERC-721 non-fungible token standard.\n * See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md.\n */\ninterface ERC721Metadata {\n    /**\n     * @dev Returns a descriptive name for a collection of NFTs in this contract.\n     * @return _name Representing name.\n     */\n    function name() external view returns (string memory _name);\n\n    /**\n     * @dev Returns a abbreviated name for a collection of NFTs in this contract.\n     * @return _symbol Representing symbol.\n     */\n    function symbol() external view returns (string memory _symbol);\n\n    /**\n     * @dev Returns a distinct Uniform Resource Identifier (URI) for a given asset. It Throws if\n     * `_tokenId` is not a valid NFT. URIs are defined in RFC3986. The URI may point to a JSON file\n     * that conforms to the \"ERC721 Metadata JSON Schema\".\n     * @return URI of _tokenId.\n     */\n    function tokenURI(uint256 _tokenId) external view returns (string memory);\n}\n"
    },
    "src/contracts/tokens/erc721.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\n/**\n@dev ERC-721 non-fungible token standard.\n */\ninterface ERC721 {\n    /**\n     * @dev Emits when ownership of any NFT changes by any mechanism. This event emits when NFTs are\n     * created (`from` == 0) and destroyed (`to` == 0). Exception: during contract creation, any\n     * number of NFTs may be created and assigned without emitting Transfer. At the time of any\n     * transfer, the approved address for that NFT (if any) is reset to none.\n     */\n    event Transfer(\n        address indexed _from,\n        address indexed _to,\n        uint256 indexed _tokenId\n    );\n\n    /**\n     * @dev This emits when the approved address for an NFT is changed or reaffirmed. The zero\n     * address indicates there is no approved address. When a Transfer event emits, this also\n     * indicates that the approved address for that NFT (if any) is reset to none.\n     */\n    event Approval(\n        address indexed _owner,\n        address indexed _approved,\n        uint256 indexed _tokenId\n    );\n\n    /**\n     * @dev This emits when an operator is enabled or disabled for an owner. The operator can manage\n     * all NFTs of the owner.\n     */\n    event ApprovalForAll(\n        address indexed _owner,\n        address indexed _operator,\n        bool _approved\n    );\n\n    /**\n     * @notice Throws unless `msg.sender` is the current owner, an authorized operator, or the\n     * approved address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is\n     * the zero address. Throws if `_tokenId` is not a valid NFT. When transfer is complete, this\n     * function checks if `_to` is a smart contract (code size > 0). If so, it calls\n     * `onERC721Received` on `_to` and throws if the return value is not\n     * `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`.\n     * @dev Transfers the ownership of an NFT from one address to another address. This function can\n     * be changed to payable.\n     * @param _from The current owner of the NFT.\n     * @param _to The new owner.\n     * @param _tokenId The NFT to transfer.\n     * @param _data Additional data with no specified format, sent in call to `_to`.\n     */\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId,\n        bytes calldata _data\n    ) external;\n\n    /**\n     * @notice This works identically to the other function with an extra data parameter, except this\n     * function just sets data to \"\"\n     * @dev Transfers the ownership of an NFT from one address to another address. This function can\n     * be changed to payable.\n     * @param _from The current owner of the NFT.\n     * @param _to The new owner.\n     * @param _tokenId The NFT to transfer.\n     */\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) external;\n\n    /**\n     * @notice The caller is responsible to confirm that `_to` is capable of receiving NFTs or else\n     * they may be permanently lost.\n     * @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\n     * address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is the zero\n     * address. Throws if `_tokenId` is not a valid NFT.  This function can be changed to payable.\n     * @param _from The current owner of the NFT.\n     * @param _to The new owner.\n     * @param _tokenId The NFT to transfer.\n     */\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) external;\n\n    /**\n     * @notice The zero address indicates there is no approved address. Throws unless `msg.sender` is\n     * the current NFT owner, or an authorized operator of the current owner.\n     * @param _approved The new approved NFT controller.\n     * @dev Set or reaffirm the approved address for an NFT. This function can be changed to payable.\n     * @param _tokenId The NFT to approve.\n     */\n    function approve(address _approved, uint256 _tokenId) external;\n\n    /**\n     * @notice The contract MUST allow multiple operators per owner.\n     * @dev Enables or disables approval for a third party (\"operator\") to manage all of\n     * `msg.sender`'s assets. It also emits the ApprovalForAll event.\n     * @param _operator Address to add to the set of authorized operators.\n     * @param _approved True if the operators is approved, false to revoke approval.\n     */\n    function setApprovalForAll(address _operator, bool _approved) external;\n\n    /**\n     * @dev Returns the number of NFTs owned by `_owner`. NFTs assigned to the zero address are\n     * considered invalid, and this function throws for queries about the zero address.\n     * @notice Count all NFTs assigned to an owner.\n     * @param _owner Address for whom to query the balance.\n     * @return Balance of _owner.\n     */\n    function balanceOf(address _owner) external view returns (uint256);\n\n    /**\n     * @notice Find the owner of an NFT.\n     * @dev Returns the address of the owner of the NFT. NFTs assigned to the zero address are\n     * considered invalid, and queries about them do throw.\n     * @param _tokenId The identifier for an NFT.\n     * @return Address of _tokenId owner.\n     */\n    function ownerOf(uint256 _tokenId) external view returns (address);\n\n    /**\n     * @notice Throws if `_tokenId` is not a valid NFT.\n     * @dev Get the approved address for a single NFT.\n     * @param _tokenId The NFT to find the approved address for.\n     * @return Address that _tokenId is approved for.\n     */\n    function getApproved(uint256 _tokenId) external view returns (address);\n\n    /**\n     * @notice Query if an address is an authorized operator for another address.\n     * @dev Returns true if `_operator` is an approved operator for `_owner`, false otherwise.\n     * @param _owner The address that owns the NFTs.\n     * @param _operator The address that acts on behalf of the owner.\n     * @return True if approved for all, false otherwise.\n     */\n    function isApprovedForAll(address _owner, address _operator)\n        external\n        view\n        returns (bool);\n}\n"
    },
    "src/contracts/tokens/erc721-token-receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\n/**\n * @dev ERC-721 interface for accepting safe transfers.\n * See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md.\n */\ninterface ERC721TokenReceiver {\n    /**\n     * @notice The contract address is always the message sender. A wallet/broker/auction application\n     * MUST implement the wallet interface if it will accept safe transfers.\n     * @dev Handle the receipt of a NFT. The ERC721 smart contract calls this function on the\n     * recipient after a `transfer`. This function MAY throw to revert and reject the transfer. Return\n     * of other than the magic value MUST result in the transaction being reverted.\n     * Returns `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))` unless throwing.\n     * @param _operator The address which called `safeTransferFrom` function.\n     * @param _from The address which previously owned the token.\n     * @param _tokenId The NFT identifier which is being transferred.\n     * @param _data Additional data with no specified format.\n     * @return Returns `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n     */\n    function onERC721Received(\n        address _operator,\n        address _from,\n        uint256 _tokenId,\n        bytes calldata _data\n    ) external returns (bytes4);\n}\n"
    },
    "src/contracts/utils/supports-interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./erc165.sol\";\n\n/**\n * @dev Implementation of standard for detect smart contract interfaces.\n */\ncontract SupportsInterface is ERC165 {\n    /**\n     * @dev Mapping of supported intefraces. You must not set element 0xffffffff to true.\n     */\n    mapping(bytes4 => bool) internal supportedInterfaces;\n\n    /**\n     * @dev Contract constructor.\n     */\n    constructor() {\n        supportedInterfaces[0x01ffc9a7] = true; // ERC165\n    }\n\n    /**\n     * @dev Function to check which interfaces are supported by this contract.\n     * @param _interfaceID Id of the interface.\n     * @return True if _interfaceID is supported, false otherwise.\n     */\n    function supportsInterface(bytes4 _interfaceID)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return supportedInterfaces[_interfaceID];\n    }\n}\n"
    },
    "src/contracts/utils/address-utils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\n/**\n * @notice Based on:\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol\n * Requires EIP-1052.\n * @dev Utility library of inline functions on addresses.\n */\nlibrary AddressUtils {\n    /**\n     * @dev Returns whether the target address is a contract.\n     * @param _addr Address to check.\n     * @return addressCheck True if _addr is a contract, false if not.\n     */\n    function isContract(address _addr)\n        internal\n        view\n        returns (bool addressCheck)\n    {\n        // This method relies in extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        assembly {\n            codehash := extcodehash(_addr)\n        } // solhint-disable-line\n        addressCheck = (codehash != 0x0 && codehash != accountHash);\n    }\n}\n"
    },
    "src/contracts/utils/erc165.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\n/**\n * @dev A standard for detecting smart contract interfaces.\n * See: https://eips.ethereum.org/EIPS/eip-165.\n */\ninterface ERC165 {\n    /**\n     * @dev Checks if the smart contract includes a specific interface.\n     * This function uses less than 30,000 gas.\n     * @param _interfaceID The interface identifier, as specified in ERC-165.\n     * @return True if _interfaceID is supported, false otherwise.\n     */\n    function supportsInterface(bytes4 _interfaceID)\n        external\n        view\n        returns (bool);\n}\n"
    },
    "src/contracts/mocks/nf-token-mock.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport \"../../contracts/tokens/nf-token.sol\";\nimport \"../ownership/ownable.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\n/**\n * @dev This is an example contract implementation of NFToken.\n */\ncontract NFTokenMock is NFToken, Ownable {\n    /**\n     * @dev Mints a new NFT.\n     * @param _to The address that will own the minted NFT.\n     * @param _tokenId of the NFT to be minted by the msg.sender.\n     */\n    function mint(address _to, uint256 _tokenId) external onlyOwner {\n        super._mint(_to, _tokenId);\n    }\n}\n"
    },
    "src/test/mocks/nf-token-test-mock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport \"../../contracts/mocks/nf-token-mock.sol\";\n\ncontract NFTokenTestMock is NFTokenMock {\n    /**\n     * @dev Removes a NFT from owner.\n     * @param _tokenId Which NFT we want to remove.\n     */\n    function burn(uint256 _tokenId) external onlyOwner {\n        super._burn(_tokenId);\n    }\n}\n"
    },
    "src/test/mocks/address-utils-mock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport \"../../contracts/utils/address-utils.sol\";\n\ncontract AddressUtilsMock {\n    using AddressUtils for address;\n\n    function isContract(address _addr)\n        external\n        view\n        returns (bool addressCheck)\n    {\n        addressCheck = _addr.isContract();\n    }\n}\n"
    },
    "src/test/mocks/nf-token-receiver-test-mock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport \"../../contracts/tokens/erc721-token-receiver.sol\";\n\ncontract NFTokenReceiverTestMock is ERC721TokenReceiver {\n    event Received();\n\n    function onERC721Received(\n        address _operator,\n        address _from,\n        uint256 _tokenId,\n        bytes calldata _data\n    ) external override returns (bytes4) {\n        _operator;\n        _from;\n        _tokenId;\n        _data;\n        emit Received();\n        return 0x150b7a02;\n    }\n}\n"
    },
    "src/contracts/mocks/nf-token-metadata-mock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport \"../tokens/nf-token-metadata.sol\";\nimport \"../ownership/ownable.sol\";\n\n/**\n * @dev This is an example contract implementation of NFToken with metadata extension.\n */\ncontract NFTokenMetadataMock is NFTokenMetadata, Ownable {\n    /**\n     * @dev Contract constructor.\n     * @param _name A descriptive name for a collection of NFTs.\n     * @param _symbol An abbreviated name for NFTokens.\n     */\n    constructor(string memory _name, string memory _symbol) {\n        nftName = _name;\n        nftSymbol = _symbol;\n    }\n\n    /**\n     * @dev Mints a new NFT.\n     * @param _to The address that will own the minted NFT.\n     * @param _tokenId of the NFT to be minted by the msg.sender.\n     * @param _uri String representing RFC 3986 URI.\n     */\n    function mint(\n        address _to,\n        uint256 _tokenId,\n        string calldata _uri\n    ) external onlyOwner {\n        super._mint(_to, _tokenId);\n        super._setTokenUri(_tokenId, _uri);\n    }\n\n    /**\n     * @dev Removes a NFT from owner.\n     * @param _tokenId Which NFT we want to remove.\n     */\n    function burn(uint256 _tokenId) external onlyOwner {\n        super._burn(_tokenId);\n    }\n}\n"
    },
    "src/test/mocks/nf-token-metadata-test-mock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport \"../../contracts/mocks/nf-token-metadata-mock.sol\";\n\ncontract NFTokenMetadataTestMock is NFTokenMetadataMock {\n    constructor(string memory _name, string memory _symbol)\n        NFTokenMetadataMock(_name, _symbol)\n    {}\n\n    function checkUri(uint256 _tokenId) external view returns (string memory) {\n        return idToUri[_tokenId];\n    }\n}\n"
    },
    "src/contracts/mocks/nf-token-metadata-base-uri-mock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport \"../tokens/nf-token-metadata.sol\";\nimport \"../ownership/ownable.sol\";\n\n/**\n * @dev This is an example contract implementation of NFToken with metadata extension.\n */\ncontract NFTokenMetadataBaseUriMock is NFTokenMetadata, Ownable {\n    /**\n     * @dev URI base for tokenURI function. Token URI is constructed as baseURI + tokenId.\n     */\n    string public baseURI;\n\n    /**\n     * @dev Contract constructor.\n     * @param _name A descriptive name for a collection of NFTs.\n     * @param _symbol An abbreviated name for NFTokens.\n     * @param _baseURI String representing base RFC 3986 URI.\n     */\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        string memory _baseURI\n    ) {\n        nftName = _name;\n        nftSymbol = _symbol;\n        baseURI = _baseURI;\n    }\n\n    /**\n     * @dev Mints a new NFT.\n     * @param _to The address that will own the minted NFT.\n     * @param _tokenId of the NFT to be minted by the msg.sender.\n     */\n    function mint(address _to, uint256 _tokenId) external onlyOwner {\n        super._mint(_to, _tokenId);\n    }\n\n    /**\n     * @dev Removes a NFT from owner.\n     * @param _tokenId Which NFT we want to remove.\n     */\n    function burn(uint256 _tokenId) external onlyOwner {\n        super._burn(_tokenId);\n    }\n\n    /**\n     * @dev A distinct URI (RFC 3986) for a given NFT.\n     * @param _tokenId Id for which we want uri.\n     * @return URI of _tokenId.\n     */\n    function _tokenURI(uint256 _tokenId)\n        internal\n        view\n        override\n        returns (string memory)\n    {\n        return\n            bytes(baseURI).length > 0\n                ? string(abi.encodePacked(baseURI, _uint2str(_tokenId)))\n                : \"\";\n    }\n\n    /**\n     * @dev Helper function that changes uint to string representation.\n     * @return str String representation.\n     */\n    function _uint2str(uint256 _i) internal pure returns (string memory str) {\n        if (_i == 0) {\n            return \"0\";\n        }\n        uint256 j = _i;\n        uint256 length;\n        while (j != 0) {\n            length++;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(length);\n        uint256 k = length;\n        j = _i;\n        while (j != 0) {\n            bstr[--k] = bytes1(uint8(48 + (j % 10)));\n            j /= 10;\n        }\n        str = string(bstr);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}